# ======================================================================
# FindVerilator.cmake
#   - Locates Verilator using pkg-config
#   - Exposes imported target Verilator::Verilator
#   - Defines macro add_verilated_testbench_custom()
# ======================================================================

include(FindPkgConfig)

pkg_check_modules(Verilator REQUIRED IMPORTED_TARGET verilator)

# ------------------------------------------------------------
# Imported target Verilator::Verilator
# ------------------------------------------------------------
add_library(Verilator::Verilator INTERFACE IMPORTED)

set_target_properties(Verilator::Verilator PROPERTIES
    INTERFACE_INCLUDE_DIRECTORIES "${PC_VERILATOR_INCLUDE_DIRS}"
    INTERFACE_LINK_LIBRARIES      "${PC_VERILATOR_LINK_LIBRARIES}"
)

# ============================================================
# Macro: add_verilated_testbench_custom
# ============================================================
#
# Usage example:
#
#   add_verilated_testbench_custom(
#       TARGET adder_tb
#       CPP_SOURCES src/adder-tb.cpp
#       CPP_INCLUDE_DIRS src
#       VERILOG_SOURCES src/adder.v
#   )
#
# This macro preserves your manual Verilator workflow:
#   - verilator --cc --exe
#   - verilator_includer
#   - create <target> executable
#
# ============================================================

macro(add_verilated_testbench_custom)
    cmake_parse_arguments(
        TB
        ""                                     # no boolean args
        "TARGET"                               # single-value args
        "CPP_SOURCES;CPP_INCLUDE_DIRS;VERILOG_SOURCES" # multi-value args
        ${ARGN}
    )

    if(NOT TB_TARGET)
        message(FATAL_ERROR "Missing TARGET argument")
    endif()

    set(OBJ_DIR ${CMAKE_CURRENT_BINARY_DIR}/obj_dir_${TB_TARGET})
    file(MAKE_DIRECTORY ${OBJ_DIR})

    # Name for V<TARGET> (Verilator output prefix)
    set(VPREFIX V${TB_TARGET})

    # Path for ALL.cpp generated by verilator_includer
    set(VALL_CPP ${OBJ_DIR}/${VPREFIX}__ALL.cpp)

    # ------------------------------------------------------------
    # 1. Run Verilator: generate C++ model
    # ------------------------------------------------------------
    add_custom_command(
        OUTPUT ${OBJ_DIR}/${VPREFIX}.cpp
        COMMAND verilator -Wall --cc
                ${TB_VERILOG_SOURCES}
                --exe ${TB_CPP_SOURCES}
                --Mdir ${OBJ_DIR}
        WORKING_DIRECTORY ${CMAKE_CURRENT_BINARY_DIR}
        COMMENT "Verilating sources for ${TB_TARGET}"
    )

    add_custom_target(${VPREFIX}_verilated
        DEPENDS ${OBJ_DIR}/${VPREFIX}.cpp
    )

    # ------------------------------------------------------------
    # 2. Run verilator_includer to create unified ALL.cpp
    # ------------------------------------------------------------
    add_custom_command(
        OUTPUT ${VALL_CPP}.in
        COMMAND /bin/sh -c
            "python3 /usr/share/verilator/bin/verilator_includer \
             -DVL_INCLUDE_OPT=include \
             ${OBJ_DIR}/${VPREFIX}__*.cpp \
             ${OBJ_DIR}/${VPREFIX}.cpp>${VALL_CPP}.in"
        DEPENDS ${VPREFIX}_verilated
        WORKING_DIRECTORY ${CMAKE_CURRENT_BINARY_DIR}
        COMMENT "Generating ${VALL_CPP}.in"
    )

    add_custom_command(
        OUTPUT ${VALL_CPP}
        COMMAND /bin/sh -c
            "cp ${VALL_CPP}.in ${VALL_CPP}"
        DEPENDS ${VALL_CPP}.in
        WORKING_DIRECTORY ${CMAKE_CURRENT_BINARY_DIR}
        COMMENT "Generating ${VALL_CPP}"
    )

    add_custom_target(${VPREFIX}_generated
        DEPENDS ${VALL_CPP}
    )

    # ------------------------------------------------------------
    # 3. Build executable for this specific testbench
    # ------------------------------------------------------------
    add_executable(${TB_TARGET}
        ${TB_CPP_SOURCES}
        ${VALL_CPP}
    )

    add_dependencies(${TB_TARGET} ${VPREFIX}_generated)

    # ------------------------------------------------------------
    # 4. Link verilated libraries (same as your script)
    # ------------------------------------------------------------
    add_library(verilated OBJECT /usr/share/verilator/include/verilated.cpp)
    add_library(verilated-threads OBJECT /usr/share/verilator/include/verilated_threads.cpp)

    target_link_libraries(${TB_TARGET}
        PRIVATE
            PkgConfig::Verilator
            verilated
            verilated-threads
    )

    # ------------------------------------------------------------
    # 5. Add include paths for user C++ code
    # ------------------------------------------------------------
    target_include_directories(${TB_TARGET}
        PRIVATE
            ${OBJ_DIR}
            ${TB_CPP_INCLUDE_DIRS}
    )

    # ------------------------------------------------------------
    # 6. Compiler settings (same as your script)
    # ------------------------------------------------------------
    target_compile_definitions(${TB_TARGET} PRIVATE
        VERILATOR=1
        VM_COVERAGE=0
        VM_SC=0
        VM_TIMING=0
        VM_TRACE=0
        VM_TRACE_FST=0
        VM_TRACE_VCD=0
        VM_TRACE_SAIF=0
    )

    target_compile_options(${TB_TARGET} PRIVATE
        -faligned-new
        -fcf-protection=none
        -Wno-bool-operation
        -Wno-int-in-bool-context
        -Wno-shadow
        -Wno-sign-compare
        -Wno-subobject-linkage
        -Wno-tautological-compare
        -Wno-uninitialized
        -Wno-unused-but-set-parameter
        -Wno-unused-but-set-variable
        -Wno-unused-parameter
        -Wno-unused-variable
        -g -O0
    )
endmacro()

set(Verilator_FOUND TRUE)